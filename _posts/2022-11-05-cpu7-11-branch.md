---
title: branch logic
published: true
---

`````verilog
exu/rtl/sparc_exu.v


   sparc_exu_ecl ecl(
                     .so                (short_so0),
                     .si                (short_scan0_1),
                     .rst_tri_en        (mux_drive_disable),
                     .byp_ecl_wrccr_data_w(byp_irf_rd_data_w[7:0]),
                     .alu_ecl_adder_out_31_e(exu_ifu_brpc_e[31]),
                     .byp_ecl_rd_data_3lsb_m(exu_tlu_wsr_data_m[2:0]),
                     .alu_ecl_adder_out_7_0_e(exu_ifu_brpc_e[7:0]),

...





   sparc_exu_alu alu(
                     .byp_alu_rs3_data_e(exu_lsu_rs3_data_e[63:0]),
                     .so                (scan0_2),
                     .si                (scan0_1),
                     .ifu_lsu_casa_e (ecl_alu_casa_e),
                     /*AUTOINST*/
                     // Outputs
                     .alu_byp_rd_data_e (alu_byp_rd_data_e[63:0]),
                     .exu_ifu_brpc_e    (exu_ifu_brpc_e[47:0]),
                     .exu_lsu_ldst_va_e (exu_lsu_ldst_va_e[47:0]),
                     .exu_lsu_early_va_e(exu_lsu_early_va_e[10:3]),
                     .exu_mmu_early_va_e(exu_mmu_early_va_e[7:0]),
                     .alu_ecl_add_n64_e (alu_ecl_add_n64_e),
                     .alu_ecl_add_n32_e (alu_ecl_add_n32_e),
                     .alu_ecl_log_n64_e (alu_ecl_log_n64_e),
                     .alu_ecl_log_n32_e (alu_ecl_log_n32_e),
...


`````

exu_ifu_brpc_e是exu给ifu的branch地址，可以看到这部分是在_e得出的。

从文档里也看到branch address的计算也是复用了ALU，应该就是ALU里的exu_ifu_brpc_e。


而在sparc_ifu.v里却有这个

`````verilog
   // Branch Logic
   sparc_ifu_dcl  dcl(
                      .so               (scan0_3),
                      .si               (scan0_2),
                                  .dtu_dcl_opf2_d       (dtu_inst_d[7]),
                      .fdp_dcl_op_s     (fdp_dtu_inst_s[31:30]),
                      .fdp_dcl_op3_s    (fdp_dtu_inst_s[24:19]),

`````

在ifu里，branch就应该是在decode阶段。

在OpenSPARC T1 Microarchitecture Specification里也有这一句。

>  2.3.14 Instruction Decode
>
>  ...
> 
>         The branch condition is also evaluated in the D-stage, and the decision for annulling
>         a delay slot is made in this stage as well.


sparc_ifu_dcl.v的注释里也说了这一点，这到要好好看看opensparc里的branch是怎样实现的。

`````verilog
ifu/rtl/sparc_ifu_dcl.v

////////////////////////////////////////////////////////////////////////
/*
//  Module Name: sparc_ifu_dcl
//  Description:        
//   The decode control logic block does branch condition evaluation,
//   delay slot management, and appropriate condition code
//   selection.  It also executes the tcc instruction and kills the E
//   stage instruction if a move did not succeed.  The DCL block is
//   also responsible for generating the correct select signals to
//   choose the branch offset and immediate operand.
//
*/
////////////////////////////////////////////////////////////////////////

`````

还在Microarchitecture Specification里看到这一段。


>  2.3.10 Thread Selection Policy
> 
>  ...
> 
>         A thread could become unavailable due to one of these reasons:
>  
>         1. The thread is executing one of the long latency instructions, such as load, branch,
>            multiplication, division, and so on.


branch也是long latency instructions？

load是，store看来不是。



-------------------------------------------------------

sparc_ifu_dcl里面是cc指令和FP cc。

比如ifu_ffu_mvcnd_m，这个名字已经很说的很清楚了。

`````verilog
ifu/rtl/sparc_ifu_dcl.v


   // branch condition to FPU
   dff_s #(1) fpcond_ff(.din  (cond_brtaken_e),
                                  .q    (ifu_ffu_mvcnd_m),
                                  .clk  (clk),
                                  .se   (se), .si(), .so());
`````

下面还有句，回头要仔细看看怎样kill write back and bypass。

`````verilog
   // if mov didn't succeed kill write back and bypass
   // need to check thread as well
//   assign ifu_exu_kill_e = dtu_inst_anull_e | 
//                         ~fcl_dtu_inst_vld_e;  // don't need this anymore
   assign ifu_exu_kill_e = dtu_inst_anull_e;

`````


------------------------------------------------

看来branch指令是应该放在_e。



`````verilog
ifu/rtl/sparc_ifu_fcl.v


   assign load_tpc[3:0] = {4{trappc_vld_w2}} & trap_thr |
                           rb_w2 |
                           {4{rb_stg_w | ims_flush_coll_w}} & thr_w |
//                     {4{dec_fcl_kill4sta_e}} & thr_e |
                           {4{flush_sonly_qual_m}} & thr_m;

   assign load_bpc[3:0] = {4{brtaken_buf_e}} & thr_e;
   assign load_pcp4[3:0] = {4{~part_stall_thisthr_f &
                              ~iferrto_thisthr_d1 |
                              arst_vld_f |
                              async_intr_vld_s}}     & thr_f;

   always @ (/*AUTOSENSE*/load_bpc or load_pcp4 or load_tpc)
     begin
//            if (fcl_reset)
//              begin // RESET PC is loaded to T0
//                 fcl_fdp_tpcbf_sel_old_bf_l = 4'b0001;
//                 fcl_fdp_tpcbf_sel_pcp4_bf_l = 4'b1110;
//                 fcl_fdp_tpcbf_sel_trap_bf_l = 4'b1111;
//                 fcl_fdp_tpcbf_sel_brpc_bf_l = 4'b1111;
//              end // if (reset)
//            else 
//              begin
              fcl_fdp_tpcbf_sel_old_bf_l = (load_bpc | load_tpc | load_pcp4);
              fcl_fdp_tpcbf_sel_brpc_bf_l = ~load_bpc | load_tpc | load_pcp4;
              fcl_fdp_tpcbf_sel_pcp4_bf_l = ~load_pcp4 | load_tpc;
              fcl_fdp_tpcbf_sel_trap_bf_l = ~load_tpc;
     end // always @ (...

`````

看到用always的时候不多啊。


---------------------------------------------------------


SPARC有两类branch指令。

The SPARC Architecture Manual V9

![screenshot0](https://github.com/whensungoesdown/whensungoesdown.github.io/raw/main/_posts/2022-11-05-0.png)
![screenshot1](https://github.com/whensungoesdown/whensungoesdown.github.io/raw/main/_posts/2022-11-05-1.png)
![screenshot2](https://github.com/whensungoesdown/whensungoesdown.github.io/raw/main/_posts/2022-11-05-2.png)

因为SPARC有状态寄存器，flags。

loongarch没有，所以可以参考Branch on Integer Register with Prediction (BPr)。

这个是寄存器里的简单比较，和0比。


在ALU里，

`````verilog
module sparc_exu_alu
(
 /*AUTOARG*/
   // Outputs
   so, alu_byp_rd_data_e, exu_ifu_brpc_e, exu_lsu_ldst_va_e, 
   exu_lsu_early_va_e, exu_mmu_early_va_e, alu_ecl_add_n64_e,
   alu_ecl_add_n32_e, alu_ecl_log_n64_e, alu_ecl_log_n32_e, 
   alu_ecl_zhigh_e, alu_ecl_zlow_e, exu_ifu_regz_e, exu_ifu_regn_e,
   alu_ecl_adderin2_63_e, alu_ecl_adderin2_31_e, 
   alu_ecl_adder_out_63_e, alu_ecl_cout32_e, alu_ecl_cout64_e_l,
   alu_ecl_mem_addr_invalid_e_l,
   // Inputs 
   rclk, se, si, byp_alu_rs1_data_e, byp_alu_rs2_data_e_l, 
   byp_alu_rs3_data_e, byp_alu_rcc_data_e, ecl_alu_cin_e, ecl_alu_rd_e, // uty: test 
   ifu_exu_invert_d, ecl_alu_log_sel_and_e, ecl_alu_log_sel_or_e,
   ecl_alu_log_sel_xor_e, ecl_alu_log_sel_move_e, 
   ecl_alu_out_sel_sum_e_l, ecl_alu_out_sel_rs3_e_l, 
   ecl_alu_out_sel_shift_e_l, ecl_alu_out_sel_logic_e_l, 
   shft_alu_shift_out_e, ecl_alu_sethi_inst_e, ifu_lsu_casa_e
   );

...

   output    exu_ifu_regz_e;              // rs1_data == 0 
   output    exu_ifu_regn_e;


...


   // Zero comparison for exu_ifu_regz_e
   sparc_exu_aluzcmp64 regzcmp(.in(byp_alu_rcc_data_e[63:0]), .zero64(exu_ifu_regz_e));
   assign     exu_ifu_regn_e = byp_alu_rcc_data_e[63];

`````

exu_ifu_regz_e和exu_ifu_regn_e能判断处rs1_data与0的关系。


`````verilog
ifu/rtl/sparc_ifu_fcl.v

//------------------------------   
// Branch Control
//------------------------------
   // final portion of branch evaluation
   wire brtaken_e_l;
   bw_u1_buf_20x UZsize_bcbf(.z(fcl_dcl_regz_e),
                             .a(exu_ifu_regz_e));

   bw_u1_muxi21_6x UZsize_bcmux(.z(brtaken_e_l),
                                .d0(dcl_fcl_bcregz0_e),
                                .d1(dcl_fcl_bcregz1_e),
                                .s(exu_ifu_regz_e));

   bw_u1_inv_15x UZsize_bcinv(.z(brtaken_e), 
                              .a(brtaken_e_l));

   // Branch is taken in the E stage to thr_e.  Below we check to see
   // if this is the same as the next thread we will switch to

   // isolate non critical section
   bw_u1_buf_5x UZsize_btbuf(.z (brtaken_unq_e),
                             .a (brtaken_e));
   assign brtaken_buf_e = brtaken_unq_e & inst_vld_qual_e & ~kill_curr_e;

//   assign thr_match_ne_norst = thr_match_ne & ~rst_sw_bf;
//   assign brto_nxtthr_bf  = thr_match_ne & brtaken_e;
   bw_u1_nand2_4x UZsize_btkn_ntl(.a (brtaken_e),
                                  .b (thr_match_ne),
                                  .z (brto_nxtthr_bf_l));

//   bw_u1_inv_8x UZsize_btkn_bf(.a (brto_nxtthr_bf_l),
//                               .z (brto_nxtthr_bf));

   dff_s #(1) br_ff(.din (brtaken_buf_e),
                              .q   (brtaken_m),
                              .clk (clk),
                              .se  (se), .si(), .so());



...


   **assign load_bpc[3:0] = {4{brtaken_buf_e}} & thr_e;**
   assign load_pcp4[3:0] = {4{~part_stall_thisthr_f &
                              ~iferrto_thisthr_d1 |
                              arst_vld_f |
                              async_intr_vld_s}}     & thr_f;

   always @ (/*AUTOSENSE*/load_bpc or load_pcp4 or load_tpc)
     begin
//            if (fcl_reset)
//              begin // RESET PC is loaded to T0
//                 fcl_fdp_tpcbf_sel_old_bf_l = 4'b0001;
//                 fcl_fdp_tpcbf_sel_pcp4_bf_l = 4'b1110;
//                 fcl_fdp_tpcbf_sel_trap_bf_l = 4'b1111;
//                 fcl_fdp_tpcbf_sel_brpc_bf_l = 4'b1111;
//              end // if (reset)
//            else 
//              begin
              fcl_fdp_tpcbf_sel_old_bf_l = (load_bpc | load_tpc | load_pcp4);
              fcl_fdp_tpcbf_sel_brpc_bf_l = ~load_bpc | load_tpc | load_pcp4;
              fcl_fdp_tpcbf_sel_pcp4_bf_l = ~load_pcp4 | load_tpc;
              fcl_fdp_tpcbf_sel_trap_bf_l = ~load_tpc;
     end // always @ (...


`````
